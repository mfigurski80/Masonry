class Masonry{constructor(t,i,e){this.elem=t,this.maxWidth=e||32;const s=t.offsetWidth/this.maxWidth;t.style.setProperty("display","grid"),t.style.setProperty("grid-auto-columns",`${s}px`),t.style.setProperty("grid-auto-rows",`${s}px`),this.maxHeight=Math.floor(this.elem.offsetHeight/s),this.centerSpace=[Math.floor(this.maxWidth/2),Math.floor(this.maxHeight/2)],this.distribution=i||"center",this.placedTiles=[],this.possibleDim=[[2,2],[2,3],[3,2]]}areTilesConflicting(t,i){return(t.x<=i.x&&i.x<t.btmX||t.x<i.btmX&&i.btmX<=t.btmX||i.x<=t.x&&t.x<i.btmX||i.x<t.btmX&&t.btmX<=i.btmX)&&(t.y<=i.y&&i.y<t.btmY||t.y<i.btmY&&i.btmY<=t.btmY||i.y<=t.y&&t.y<i.btmY||i.y<t.btmY&&t.btmY<=i.btmY)}isTilePosAcceptable(t){for(let i of this.placedTiles)if(this.areTilesConflicting(t,i))return!1;return!(t.x<1||t.y<1||t.btmX-1>this.maxWidth&&"left"!=this.distribution||t.btmY-1>this.maxHeight&&"top"!=this.distribution)}getRandSizeTile(){const t=Math.floor(Math.random()*this.possibleDim.length);return new Tile(1,1,this.possibleDim[t][0],this.possibleDim[t][1])}isTileFit(t,i){return t.setXY(i[0],i[1]),!!this.isTilePosAcceptable(t)||(t.shiftX(),!!this.isTilePosAcceptable(t)||(t.shiftY(),!!this.isTilePosAcceptable(t)||(t.unshiftX(),!!this.isTilePosAcceptable(t))))}getNextSpaceToCheck(t){var i=[];if("center"==this.distribution)0==t.length&&(i=[this.centerSpace]),t.forEach(t=>{t[0]>=this.centerSpace[0]&&i.push([t[0]+1,t[1]]),t[0]<=this.centerSpace[0]&&i.push([t[0]-1,t[1]]),t[0]==this.centerSpace[0]&&(t[1]>=this.centerSpace[1]&&i.push([t[0],t[1]+1]),t[1]<=this.centerSpace[1]&&i.push([t[0],t[1]-1]))});else if("top"==this.distribution){if(0==t.length)for(var e=1;e<this.maxWidth;e++)i.push([e,1]);t.forEach(t=>{i.push([t[0],t[1]+1])})}else if("left"==this.distribution){if(0==t.length)for(e=1;e<this.maxHeight;e++)i.push([1,e]);t.forEach(t=>{i.push([t[0]+1,t[1]])})}var s=[];return i.forEach(t=>{t[0]<=0||t[0]>this.maxWidth||t[1]<=0||t[1]>this.maxHeight?(t[0]>this.maxWidth&&"left"==this.distribution||t[1]>this.maxHeight&&"top"==this.distribution)&&s.push(t):s.push(t)}),s}placeTilesByClass(t){const i=[...document.getElementsByClassName(t)];let e=[];i.forEach(t=>{let i=this.getRandSizeTile();i.setElem(t);let s=[i.elem.getAttribute("height"),i.elem.getAttribute("width")];null!=s[0]&&i.setDim(parseInt(s[0]),i.width),null!=s[1]&&i.setDim(i.height,parseInt(s[1])),e.push(i)}),this.placeTiles(e)}placeGeneratedTile(t,i,e){t=t||[],i=i||"";const s=document.createElement("DIV");t.forEach(t=>s.classList.add(t)),s.innerHTML=e;const h=this.getRandSizeTile();return h.setElem(s),s.setAttribute("style",`${s.getAttribute("style")} ${i}`),!!this.placeTiles([h])&&(this.elem.appendChild(s),!0)}placeTiles(t){for(var i=[];t.length>0;){if(0==(i=this.getNextSpaceToCheck(i)).length)return!1;i.forEach(i=>{if(t.length<=0)return!0;var e=t[0];this.isTileFit(e,i)&&(e.render(),this.placedTiles.push(e),t.splice(0,1))})}return!0}toString(){var t="";return this.placedTiles.forEach(i=>{t+=`${i.toString()}\n`}),t}}class Tile{constructor(t,i,e,s){this.x=t,this.y=i,this.height=e,this.width=s,this.resetBtm()}setElem(t){this.elem=t}setXY(t,i){this.x=t,this.y=i,this.resetBtm()}setDim(t,i){this.height=t,this.width=i,this.resetBtm()}resetBtm(){this.btmX=this.x+this.width,this.btmY=this.y+this.height}shiftX(){this.x=this.x-this.width+1,this.resetBtm()}shiftY(){this.y=this.y-this.height+1,this.resetBtm()}unshiftX(){this.x=this.x+this.width-1,this.resetBtm()}unshiftY(){this.y=this.y+this.height-1,this.resetBtm()}render(){if(!this.elem)return console.error("No DOM element specified for render");this.elem.setAttribute("style","grid-column-start: "+this.x+"; grid-column-end: "+this.btmX+"; grid-row-start: "+this.y+"; grid-row-end: "+this.btmY+";")}copy(){const t=new Tile(this.x,this.y,this.height,this.width);return t.setElem(this.elem),t}toString(){return`Tile: {x: ${this.x}, y: ${this.y},\nheight: ${this.height}, width: ${this.width},\nbtmX: ${this.btmX}, btmY: ${this.btmY}}`}}